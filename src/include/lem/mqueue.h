// -----------------------------------------------------------------------------
// File MQUEUE.H
//
// (c) Koziev Elijah, Obninsk-Cherepovets, Russia, 1995-2010
//
// Content:
//  ласс MQueue - универсальный шаблон-контейнер дл€ очередей, которые
// имеют ограниченную (или произвольную) длину!
//
// »наче говор€, элемент, помещенный первым, первым же и извлекаетс
// (FIRST IN - FIRST OUT, FIFO). ≈сли задана максимальна€ длина очереди, то
// по достижении этого кол-ва элементов добавление очередного приводит к сдвигу
// всей очереди к началу, первый элемент выбрасываетс€.
//
// “ак как данный шаблон построен на основе
// класса универсального контейнера, то можно обращатьс€ к любым элементам
// очереди. NOTA BENE: данна€ очередь предполагает, что элементы нормально
// копируютс€ без использовани€ конструкторов и деструкторов, посредством
// memcpy. ѕодробнее - смотри класс MCollect.
// -----------------------------------------------------------------------------
//
// CD->03.09.2002
// LC->25.05.2010
// --------------

#ifndef LEM_MQUEUE__H
#define LEM_MQUEUE__H
#pragma once

 #include <algorithm>
 #include <lem/containers.h>

 namespace lem
 {
  // *********************************************************************
  // ѕросто очередь. ћы просто добавили пару методов pop и push.
  // *********************************************************************
  template <class ITEM> class MQueue : public MCollect<ITEM>
  {
   public:
    MQueue( int n0=0 ) : MCollect<ITEM>() {}

    /******************************************************
     ѕомещение элемента в конец очереди.
    *******************************************************/
    inline void push( const ITEM &to_add ) { push_back(to_add); }

    /*****************************************************************
     »звлечение одного элемента из головы очереди, то есть помещенного
     в нее раньше всех. ќчередь после извлечени€ сдвигаетс€.
    ******************************************************************/
    const ITEM pop(void)
    {
     LEM_CHECKIT_Z(!MQueue<ITEM>::empty());
     const ITEM res = MQueue<ITEM>::front();
     MQueue<ITEM>::erase( MQueue<ITEM>::begin() );
     return res;
    }
  };

  // *****************************************************************
  // “еперь очередь с ограничением на длину.
  // *****************************************************************
  template <class ITEM> class MLimQueue : public MQueue<ITEM>
  {
   private:
    int nmax; // ћаксимальна€ длина очереди

   public:
    // *******************************************************
    // јргумент конструктора - максимальна€ длина очереди.
    // *******************************************************
    MLimQueue( int NMAX ):MQueue<ITEM>()
    { nmax=NMAX; }

    inline void SetLimit( int nMax ) { nmax=nMax; }
    inline int Limit(void) const { return nmax; }

    inline void insert( const ITEM &toAdd )
    {
     // ќчередь достигла максимальной длины?
     if( CastSizeToInt(MQueue<ITEM>::size())==nmax )
      MQueue<ITEM>::Remove(0); // ”дал€ем первый элемент

     MQueue<ITEM>::push_back(toAdd);
     return;
    }
  };

 } // end of namespace 'lem'

#endif
