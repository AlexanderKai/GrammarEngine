// -------------------------------------------------------------------------
// File CFG_BASE_PARSER.CPP
//
// (c) by Koziev Elijah, Obninsk-Cherepovets, Russia, 1995-2004
//
// Content:
// Работа с конфигурационными файлами.
// ------------------------------------------------------------------------
//
// CD->21.07.95
// LC->01.12.04
// ------------

#include <lem/cfg_parser.h>

using namespace std;
using namespace lem;
using namespace lem::Cfg_Parser;

/********************************************************************************

            Операции с файлами конфигурации (ini-файлами)

   Для удобства работы со сложно организованной текстовой информацией
 для программ предлагается набор классов построения и обработки древовидных
 структур.

   Работа класса ProFile основана на хорошо себя зарекомендовавших методах
 класса Text_Parser, который способен разбивать тексты с С++ - подобным синтаксисом
 на отдельные лексемы и игнорировать комментарии.

   Конструктор класса ProFile строит дерево структуры текстового файла, имя
 которого ему передано как параметр. Формат файла должен быть следующим:


 [section_name]
  {
   any information

   [subsection_name]
    {
     { any information }

     [subsection name]
     {
      any information
     }
    }

   [subsection name]
    {
     any information
    }
  }

   Имя каждой секции заключается в квадратные скобочки. Имя может состоять из
 произвольного количества слов с произвольными символами кроме ']'. Тело секции
 размещается после заголовка секции в фигурных скобочках '{}'. Наличие пробельных
 отступов, подчеркивающих иерархическую структуру файла, совершенно не влияет на
 работу класса. Допускается произвольная вложенность секций, при этом вложенные
 секции одного подуровня располагаются внутри фигурных скобочек своей корневой
 секции.

   Заголовки подсекций могут быть произвольно разбросаны внутри блока своей
 корневой секции, а также перемешаны с любой текстовой информацей. Внутри блока
 секции допускается помещать парные фигурные скобочки, которые не начинаются
 заголовком подсекции и не принимаются в расчет при построении структуры. Такие
 парные скобочки могут быть вложенными, и содержать произвольную информацию или
 новые вложенные секции, которые включаются в общую структуру.

   При необходимости часть информации может быть скрыта от чтения помещением в
 блок комментария типа C:
                         /*
                             :
                           comment
                             :
                         */
/*
 Также можно использовать комментарий до конца строки - стиль C++:

                         // ...comment....

   Комментарии полностью игнорируются при обработке, для их прочтения
 необходимо принимать специальные программные меры.

   Число и расположение пробелов не играют никакой роли. Исходный текст разбивается
 на лексемы с учетом как пробелов, так и обычных разделителей C/C++. Следует
 заметить, что при нормальном функционировании методы класса Text_Parser и ProFile
 не возвращают строку, состоящую из одних пробелов.

   Хотя пробелы при считывании информации выкидываются, можно заставить процедуры
 прочитать какой-либо кусок без какой-либо обработки, если поместить его в двойные
 кавычки, то бишь определить его как текстовую строку С/C++. Также можно использовать
 одинарный апостроф (стандартное определение символа в языке C/C++).

   После считывания иерархической структуры файла, по построенному дереву можно
 перемещаться с использованием принципов, аналогичных оным для файловой системы.
 Каждая секция специфицируется путем, который состоит из имен секций, специальных
 символов и разделителей имен '\' (\\ в строках программы на C/C++ естественно!).
 Особых символов немного:

  : - переход в корень всей структуры.

  . - возврат на один уровень назад.
  несколько '.' - возврат на соотв. число уровней назад.

 Таким образом, пути могут быть представлены так:

      ":\\first\\first_first\\first_first_fifth"

      ".\\another"

      "...\\name can contain blanks"


   После перехода к какой-либо секции она становится текущей корневой, и
 последующая адресация берется отностительно нее. Для адресации от корня всего
 дерева достаточно использовать имя ':', как в первом примере пути.

   При необходимости, можно путешествовать по дереву без явного задания путей,
 а используя команды next, prev, up, down. Но специфическая структура дерева может
 помешать выполнить некоторые желательные перемещения без дополнительного анализа
 текущей ситуации на каждом уровне.

       +---------+
       |         |
       | _root_  |
       |         |
       +------*--+
         |    |
         |    |
        SUB SUPER
         |    |
         |    |
       +-*-------+        +--------+        +--------+
       |         |--NEXT-->        |--NEXT-->        |
       |  leaf   |        |  leaf  |        |  leaf  |
       |         <--PREV--|        <--PREV--|        |
       +---------+        +------*-+        +--------+
                            |    |
                            |    |
                           SUB SUPER
                            |    |
                            |    |
       +---------+        +-*------+
       |         |--NEXT-->        |
       |  leaf   |        |  leaf  |
       |         <--PREV--|        |
       +------*--+        +--------+
         |    |
         |    |
        SUB SUPER
         |    |
         |    |
       +-*-------+
       |         |
       |  leaf   |
       |         |
       +---------+


   Очевидно, что без знания адресов листочков в реально построенном дереве
 можно запросто запутаться.

   После успешного перехода к секции с полмощью метода seek, можно начать
 чтение информации из секции. Чтение осуществляется методом NextFromSection.
 Если на пути встречается заголовок подсекции, то подсекция вместе со своими
 подсекциями обходится. Таким образом, читается только содержательная часть
 секции.

   Имя секции "_root_" зарезервированно и не должно использоваться.
******************************************************************************/

// -------------------------------------------
// Разбиваем путь к секции на отдельные имена.
// -------------------------------------------
int lem::Cfg_Parser::ParseSectionPath( const string &sec_name, string **name )
{
 if( sec_name.empty() )
  return 0;

 // 1. Подсчитаем, сколько имен подсекций.
 int l=sec_name.length();
 int i, nsec=1;
 for( i=0; i<l; i++ )
  if( sec_name[i]=='\\' )
   nsec++;

 // Теперь разбиваем путь на имена отдельных
 // подсекций.
 *name = new string[nsec];

 int ipos=0;
 for( i=0; i<nsec; i++ )
  {
   while(ipos!=l)
    {
     char ch=sec_name[ipos++];

     if(ch=='\\')
      break;

     // Добавляем символ к имени подсекции.
     (*name)[i] += ch;
    }
  }

 return nsec;
}


// ---------------------- End Of File [CFG_BASE_PARSER.CPP] --------------------
