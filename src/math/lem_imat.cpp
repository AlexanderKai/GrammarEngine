// -----------------------------------------------------------------------------
// File LEM_IMAT.CPP
//
// (c) 2005 by Koziev Elijah     all rights reserved 
//
// SOLARIX Intellectronix Project http://www.solarix.ru
//                                http://sourceforge.net/projects/solarix  
//
// Licensed under the terms of GNU Lesser GPL
// You must not eliminate, delete or supress these copyright strings
// from the file!
//
// Content:
// LEM C++ library  http://www.solarix.ru
// Быстрые операции над целочисленными операндами. Также всячая всякина по
// теории чисел.
//
// 03.06.2004 - перенесено в 'lem' namespace
// -----------------------------------------------------------------------------
//
// CD->22.16.1998
// LC->29.12.2006
// --------------

#include <lem/runtime_checks.h>
#include <lem/math/integer_math.h>

using namespace lem;

// ---------------------------------------------------------
// Обычный подход к определению факториала - перемножение...
// Returns the factorial of an integer number.
//
// Переполнение не ловится...
// ---------------------------------------------------------

static const long ftabl[13]=
{
 1L,          // 0!
 1L,          // 1!
 2L,          // 2!
 6L,          // 3!
 24L,         // 4!
 120L,        // 5!
 720L,        // 6!
 5040L,       // 7!
 40320L,      // 8!
 362880L,     // 9!
 3628800L,    // 10!
 39916800L,   // 11!
 479001600L   // 12!
};

long lem::Math::ifact( int NN )
{
 int n=NN;
 LEM_CHECKIT_Z(n>=0);

 if( n< int(DIM_A(ftabl)) )
  return ftabl[n];

 // Пропускаем 13 первых умножений.
 long N = int(DIM_A(ftabl))-1;
 long i = int(DIM_A(ftabl));
 n -= (int(DIM_A(ftabl))-1);

 while(n--) N *= i++;

 return N;
}


/***********************************************************************
 Выполняем вычисление степени двойки: 2^n. Переполнение результата не
 контролируется, целочисленная арифметика.
************************************************************************/
unsigned long lem::Math::lpow2n( unsigned int n )
{
 unsigned long res=1ul;
 for( int i=n; i>0; i-- )
  res *= 2ul;

 return res;
}

/***************************************************************************
 Находит логарифм числа по основанию 2. Работаем в целых числах, поэтому
 следует внимательно отнестись к правилу округления:

              x      результат
              0         -
              1         0
              2         1
              3         1
              4         2
              5         2
              6         2
              7         2
              8         3

 То есть мы просто "отбрасываем" все цифры после запятой.
***************************************************************************/
unsigned int lem::Math::llog2( unsigned long x )
{
 LEM_CHECKIT_Z(x);

 unsigned long r2 = x;
 unsigned int res = 0;

 while( r2>1 )
  {
   r2/=2ul;
   res++;
  }

 return res;
}

// -------------------------------------------------------------------------
// Находим квадратный корень аргумента методом последовательных приближений.
// Также применяется оценка первого приближения корня по таблице.
// -------------------------------------------------------------------------

/*
static int16_t isqrt_table[16]=
                             {
                              48,  // < 4096
                              80,  // < 8192
                              100, // < 12288
                              120, // < 16384
                              136, // < 20480
                              148, // < 24576
                              160, // < 28672
                              174, // < 32768
                              184, // < 36864
                              194, // < 40960
                              204, // < 45056
                              216, // < 49152
                              224, // < 53248
                              234, // < 57344
                              240, // < 61440
                              252  // < 65536
                             };

int16_t lem::Math::isqrt( int16_t a )
{
 if(a<2)
  return a;

 // Начальное приближение берем из таблички.
 int16_t x=isqrt_table[a>>12];
 int16_t x1,dx;

 // Крутим итерации до повторения корня.
 do
  {
   x=(a/x+(x1=x))>>1;
   dx=x-x1;
  }
 while( dx>1 || dx<-1 );

 // Следует заметить, что из-за дискретности целых
 // чисел может возникнуть последовательность типа
 // 20, 21, 20, 21 ... и т.д. Поэтому проверка
 // выхода их цикла выглядит хитровато.
 return x;
}
*/

// --------------------------------------------------------------------------
// Находим квадратный корень аргумента методом последовательных приближений.
// Также применяется оценка первого приближения корня по таблице. Поэтому
// итерации достаточно быстро сходятся.
// --------------------------------------------------------------------------
static const long lsqrt_table[256]=
{
  2896l /* <   8388608 */,
  4096l /* <  16777216 */,
  5017l /* <  25165824 */,
  5793l /* <  33554432 */,
  6476l /* <  41943040 */,
  7094l /* <  50331648 */,
  7663l /* <  58720256 */,
  8192l /* <  67108864 */,
  8689l /* <  75497472 */,
  9159l /* <  83886080 */,
  9606l /* <  92274688 */,
 10033l /* < 100663296 */,
 10443l /* < 109051904 */,
 10837l /* < 117440512 */,
 11217l /* < 125829120 */,
 11585l /* < 134217728 */,
 11942l /* < 142606336 */,
 12288l /* < 150994944 */,
 12625l /* < 159383552 */,
 12953l /* < 167772160 */,
 13273l /* < 176160768 */,
 13585l /* < 184549376 */,
 13890l /* < 192937984 */,
 14189l /* < 201326592 */,
 14482l /* < 209715200 */,
 14768l /* < 218103808 */,
 15050l /* < 226492416 */,
 15326l /* < 234881024 */,
 15597l /* < 243269632 */,
 15864l /* < 251658240 */,
 16126l /* < 260046848 */,
 16384l /* < 268435456 */,
 16638l /* < 276824064 */,
 16888l /* < 285212672 */,
 17135l /* < 293601280 */,
 17378l /* < 301989888 */,
 17618l /* < 310378496 */,
 17854l /* < 318767104 */,
 18087l /* < 327155712 */,
 18318l /* < 335544320 */,
 18545l /* < 343932928 */,
 18770l /* < 352321536 */,
 18992l /* < 360710144 */,
 19212l /* < 369098752 */,
 19429l /* < 377487360 */,
 19644l /* < 385875968 */,
 19856l /* < 394264576 */,
 20066l /* < 402653184 */,
 20274l /* < 411041792 */,
 20480l /* < 419430400 */,
 20684l /* < 427819008 */,
 20886l /* < 436207616 */,
 21085l /* < 444596224 */,
 21283l /* < 452984832 */,
 21480l /* < 461373440 */,
 21674l /* < 469762048 */,
 21867l /* < 478150656 */,
 22058l /* < 486539264 */,
 22247l /* < 494927872 */,
 22435l /* < 503316480 */,
 22621l /* < 511705088 */,
 22806l /* < 520093696 */,
 22989l /* < 528482304 */,
 23170l /* < 536870912 */,
 23351l /* < 545259520 */,
 23530l /* < 553648128 */,
 23707l /* < 562036736 */,
 23884l /* < 570425344 */,
 24059l /* < 578813952 */,
 24232l /* < 587202560 */,
 24405l /* < 595591168 */,
 24576l /* < 603979776 */,
 24746l /* < 612368384 */,
 24915l /* < 620756992 */,
 25083l /* < 629145600 */,
 25249l /* < 637534208 */,
 25415l /* < 645922816 */,
 25580l /* < 654311424 */,
 25743l /* < 662700032 */,
 25905l /* < 671088640 */,
 26067l /* < 679477248 */,
 26227l /* < 687865856 */,
 26387l /* < 696254464 */,
 26545l /* < 704643072 */,
 26703l /* < 713031680 */,
 26859l /* < 721420288 */,
 27015l /* < 729808896 */,
 27170l /* < 738197504 */,
 27324l /* < 746586112 */,
 27477l /* < 754974720 */,
 27629l /* < 763363328 */,
 27780l /* < 771751936 */,
 27931l /* < 780140544 */,
 28081l /* < 788529152 */,
 28230l /* < 796917760 */,
 28378l /* < 805306368 */,
 28525l /* < 813694976 */,
 28672l /* < 822083584 */,
 28818l /* < 830472192 */,
 28963l /* < 838860800 */,
 29108l /* < 847249408 */,
 29251l /* < 855638016 */,
 29394l /* < 864026624 */,
 29537l /* < 872415232 */,
 29678l /* < 880803840 */,
 29819l /* < 889192448 */,
 29960l /* < 897581056 */,
 30099l /* < 905969664 */,
 30238l /* < 914358272 */,
 30377l /* < 922746880 */,
 30515l /* < 931135488 */,
 30652l /* < 939524096 */,
 30788l /* < 947912704 */,
 30924l /* < 956301312 */,
 31059l /* < 964689920 */,
 31194l /* < 973078528 */,
 31328l /* < 981467136 */,
 31462l /* < 989855744 */,
 31595l /* < 998244352 */,
 31727l /* <1006632960 */,
 31859l /* <1015021568 */,
 31991l /* <1023410176 */,
 32122l /* <1031798784 */,
 32252l /* <1040187392 */,
 32382l /* <1048576000 */,
 32511l /* <1056964608 */,
 32640l /* <1065353216 */,
 32768l /* <1073741824 */,
 32896l /* <1082130432 */,
 33023l /* <1090519040 */,
 33150l /* <1098907648 */,
 33276l /* <1107296256 */,
 33402l /* <1115684864 */,
 33527l /* <1124073472 */,
 33652l /* <1132462080 */,
 33776l /* <1140850688 */,
 33900l /* <1149239296 */,
 34024l /* <1157627904 */,
 34147l /* <1166016512 */,
 34270l /* <1174405120 */,
 34392l /* <1182793728 */,
 34514l /* <1191182336 */,
 34635l /* <1199570944 */,
 34756l /* <1207959552 */,
 34876l /* <1216348160 */,
 34996l /* <1224736768 */,
 35116l /* <1233125376 */,
 35235l /* <1241513984 */,
 35354l /* <1249902592 */,
 35472l /* <1258291200 */,
 35590l /* <1266679808 */,
 35708l /* <1275068416 */,
 35825l /* <1283457024 */,
 35942l /* <1291845632 */,
 36059l /* <1300234240 */,
 36175l /* <1308622848 */,
 36291l /* <1317011456 */,
 36406l /* <1325400064 */,
 36521l /* <1333788672 */,
 36636l /* <1342177280 */,
 36750l /* <1350565888 */,
 36864l /* <1358954496 */,
 36978l /* <1367343104 */,
 37091l /* <1375731712 */,
 37204l /* <1384120320 */,
 37316l /* <1392508928 */,
 37429l /* <1400897536 */,
 37540l /* <1409286144 */,
 37652l /* <1417674752 */,
 37763l /* <1426063360 */,
 37874l /* <1434451968 */,
 37985l /* <1442840576 */,
 38095l /* <1451229184 */,
 38205l /* <1459617792 */,
 38315l /* <1468006400 */,
 38424l /* <1476395008 */,
 38533l /* <1484783616 */,
 38642l /* <1493172224 */,
 38750l /* <1501560832 */,
 38858l /* <1509949440 */,
 38966l /* <1518338048 */,
 39073l /* <1526726656 */,
 39181l /* <1535115264 */,
 39287l /* <1543503872 */,
 39394l /* <1551892480 */,
 39500l /* <1560281088 */,
 39606l /* <1568669696 */,
 39712l /* <1577058304 */,
 39818l /* <1585446912 */,
 39923l /* <1593835520 */,
 40028l /* <1602224128 */,
 40132l /* <1610612736 */,
 40237l /* <1619001344 */,
 40341l /* <1627389952 */,
 40445l /* <1635778560 */,
 40548l /* <1644167168 */,
 40652l /* <1652555776 */,
 40755l /* <1660944384 */,
 40857l /* <1669332992 */,
 40960l /* <1677721600 */,
 41062l /* <1686110208 */,
 41164l /* <1694498816 */,
 41266l /* <1702887424 */,
 41368l /* <1711276032 */,
 41469l /* <1719664640 */,
 41570l /* <1728053248 */,
 41671l /* <1736441856 */,
 41771l /* <1744830464 */,
 41871l /* <1753219072 */,
 41972l /* <1761607680 */,
 42071l /* <1769996288 */,
 42171l /* <1778384896 */,
 42270l /* <1786773504 */,
 42369l /* <1795162112 */,
 42468l /* <1803550720 */,
 42567l /* <1811939328 */,
 42665l /* <1820327936 */,
 42763l /* <1828716544 */,
 42861l /* <1837105152 */,
 42959l /* <1845493760 */,
 43057l /* <1853882368 */,
 43154l /* <1862270976 */,
 43251l /* <1870659584 */,
 43348l /* <1879048192 */,
 43445l /* <1887436800 */,
 43541l /* <1895825408 */,
 43637l /* <1904214016 */,
 43733l /* <1912602624 */,
 43829l /* <1920991232 */,
 43925l /* <1929379840 */,
 44020l /* <1937768448 */,
 44115l /* <1946157056 */,
 44210l /* <1954545664 */,
 44305l /* <1962934272 */,
 44400l /* <1971322880 */,
 44494l /* <1979711488 */,
 44588l /* <1988100096 */,
 44682l /* <1996488704 */,
 44776l /* <2004877312 */,
 44869l /* <2013265920 */,
 44963l /* <2021654528 */,
 45056l /* <2030043136 */,
 45149l /* <2038431744 */,
 45242l /* <2046820352 */,
 45334l /* <2055208960 */,
 45427l /* <2063597568 */,
 45519l /* <2071986176 */,
 45611l /* <2080374784 */,
 45703l /* <2088763392 */,
 45795l /* <2097152000 */,
 45886l /* <2105540608 */,
 45977l /* <2113929216 */,
 46069l /* <2122317824 */,
 46160l /* <2130706432 */,
 46250l /* <2139095040 */
};

int lem::Math::isqrt( int a )
{
 if(a<2) return a;

 // Начальное приближение берем из статической таблички.
 int x=lsqrt_table[int(a>>23)];
 int x1,dx;

 // Крутим итерации до повторения приближения корня.
 do
  {
   x=(a/x+(x1=x))>>1;
   dx=x-x1;
  }
 while( dx>1 || dx<-1 );

 // Следует заметить, что из-за дискретности целых
 // чисел может возникнуть последовательность типа
 // 20, 21, 20, 21 ... и т.д. Поэтому проверка
 // выхода их цикла выглядит хитровато.
 return x;
}

// Быстрый синус.
static int sint[100]= {
0,174,348,523,697,871,1045,1218,1391,1564,1736,
1908,2079,2249,2419,2588,2756,2923,3090,3255,3420,
3583,3746,3907,4067,4226,4383,4539,4694,4848,4999,
5150,5299,5446,5591,5735,5877,6018,6156,6293,6427,
6560,6691,6819,6946,7071,7193,7313,7431,7547,7660,
7771,7880,7986,8090,8191,8290,8386,8480,8571,8660,
8746,8829,8910,8987,9063,9135,9205,9271,9335,9396,
9455,9510,9563,9612,9659,9702,9743,9781,9816,9848,
9876,9902,9925,9945,9961,9975,9986,9993,9998,10000
};

// -------------------------------------------------
// Аргумент функции задается в градусах.
// Результат - числитель дроби, знаменателем
// всегда является число 10000.
//
// Таким образом, вызов фунции строкой:
//
//     REAL sina = isin(45)/10000.;
//
// приведет к правильному результату.
//
// Максимальная ошибка - для угла 1, достигает 1%.
// Типичная ошибка - 0.01 %
// -------------------------------------------------
int lem::Math::isin( int angle )
{
 if(angle<0) angle+=360;

 int a=0,sg=0;

 switch(angle/90) // Квадрант.
  {
   case 0: a=angle;     sg=1; break;
   case 1: a=180-angle; sg=1; break;
   case 2: a=angle-180; sg=-1;break;
   case 3: a=360-angle; sg=-1;break;
  }

 return sg>0 ? sint[a] : -sint[a];
}

static int cost[100]={
10000,9998,9993,9986,9975,9961,9945,9925,9902,9876,9848,
9816,9781,9743,9702,9659,9612,9563,9510,9455,9396,
9335,9271,9205,9135,9063,8987,8910,8829,8746,8660,
8571,8480,8386,8290,8191,8090,7986,7880,7771,7660,
7547,7431,7313,7193,7071,6946,6819,6691,6560,6427,
6293,6156,6018,5877,5735,5591,5446,5299,5150,5000,
4848,4694,4539,4383,4226,4067,3907,3746,3583,3420,
3255,3090,2923,2756,2588,2419,2249,2079,1908,1736,
1564,1391,1218,1045,871,697,523,348,174,0
};

int lem::Math::icos( int angle )
{
 if(angle<0)
  angle+=360;

 int a=0,sg=0;
 switch(angle/90) // Квадрант.
  {
   case 0: a=angle;     sg=1;  break;
   case 1: a=180-angle; sg=-1; break;
   case 2: a=angle-180; sg=-1; break;
   case 3: a=360-angle; sg=1;  break;
  }

 return sg>0 ? cost[a] : -cost[a];
}

// *****************************************************
// Аргумент - простое число?
// *****************************************************
bool lem::Math::isprime( long a )
{
 const long p[]={2,3,5,7,9,11,13,17,19,23};

 int i;
 for( i=0; i<int(DIM_A(p)) && a>p[i]; i++ )
  if( !(a%p[i]) )
   return false;

 long a2 = isqrt(a);
 i=1;

 do
  {
   i+=2;

   if( !(a%i) )
    return false;
  }
 while( i<a2 );

 return true;
}

